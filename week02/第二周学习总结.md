
## 1、JS语言通识

#### 1.1泛用语言分类
**(1) 分类**
* 非形式语言 (中文或英文)
* 形式语言 （按乔姆斯基谱系分类）
    * 0型：无限制文法  (定义语言是什么样就是什么样); BNF表示：`?::=?`
    * 1型：上下文相关文法(同样的词句的组合是跟上下文内容相关的); BNF表示：`?<A>?::=?<B>?`
    * 2型：上下文无关文法 (同样一个表达，不管放在哪里，都是一样的意思) BNF表示：`<A>::=?`
    * 3型：正则文法 （能够被正则表达式去描述的一种文法） BNF表示：`<A>::=<A>?`

    
    >形式语言特点：包含关系，下面的包含上面的所有，比如，2型包含0型和1型（即属于0型也属于1型）反过来则不成立`

**(2)产生式（BNF）**
> BNF:描述产生式的一个工具
* 用尖括号括起来的名称表示语法结构名
* 语法结构
    * 终结符（类似于树结构中的叶子节点）
    * 非终结符(类似于非叶子节点)
* 用引号和其中间的字符表示终结符（即字符串系形式）
* 有括号(把不同的语法结构括起来)
* \* 表示重复多次
* | 表示或
* \+ 表示至少一次

#### 1.2 现代语言分类
可以按用途和按表达方式等分类。
* 按用途
    * 数据描述语言（JSON、 HTML、 XAML、 SQL 、CSS等）
    * 编程语言（Javascript、 Java、C、 C++、C#、Python  Ruby、Lisp、Clojure等）
* 按表达方式
    * 声明式语言（JSON、 HTML、 XAML、 SQL 、CSS、Lisp、Clojure）
    * 命令式语言（Javascript、 Java、C、 C++、C#、Python  Ruby）

#### 1.3 编程语言性质
* 图灵完备性
* 动态和静态
* 类型系统

#### 1.4 一般命令式编程语言的设计方式
* 原子级：Atom  （关键字、变量名、直接量）
* 表达式：Expression  （由原子通过运算符连接或者加上一些特殊的符号）
* 语句：Statement （由表达式加上特定标识符、符号形成）
* 结构化：Structure （组织代码，把代码分成不同的块，便于复用）
* 程序：Program （管理模块和安装）


## 2、JS类型 
Javascript按照运行时类型，共分为7种类型：
* Undefined
* Null
* Boolean
* Number
* String
* Symbol
* Object

#### 2.1 Undefined
Undefined类型只有一个值，即 `undefined`，表示未定义;

`注意`：undefined是一个变量，它的值可能被重新赋值，所以使用undefined来获取Undefined类型的值并不可靠，正确做法可以使用：`void 0`；

#### 2.2 Null
Null类型只有一个值：null，表示定义了，但是定义了一个空值。
> 问题：typeof null === object的原因
js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息.
000：对象
010：浮点数
100：字符串
110：布尔
1：整数
但对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的：
null：所有机器码均为0
undefined：用 −2^30 整数来表示
所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。

#### 2.3 Boolean
Boolean类型有两个值： true 和false (都是关键字)

#### 2.4 Number
Number类型表示双精度浮点类型。

(1) **不同进制**
十进制：0 | 0. | .0 | 1e3 
二进制：0b开头，后面数字0至1， eg. 0b111
八进制：0o开头，后面数字0至7， eg. 0o72
十六进制：0x开头，后面数字0-9至a-f， eg. 0xff

(2) **双精度浮点数**
数字组成：
* 符号位S(1)
* 指数位E(11)
* 精度位M(52)

最后的float数：精度位乘以2的指数次方.

在科学计数法中指数E是可以为负数的，在表示负的指数时IEEE754标准引入了一个偏移量1023，即01111111111，在存储指数时加上该偏移量把负数E转成正数。这就导致11位的指数能够表示指数的范围是[-1023, 1024]。
![](https://segmentfault.com/img/bV2YkY?w=492&h=84)

在精度位前面还有一个隐藏位1
1: `(-1)^0 * 2^(1023-1023)*(0+1)`;  此时E：01111111111 = 1023
2: `(-1)^0 * 2^(1024-1023)*(0+1)`;  此时E：10000000000 = 1024
4: `(-1)^0 * 2^(1025-1023)*(0+1)`;  此时E：10000000001 = 1025
8: `(-1)^0 * 2^(1026-1023)*(0+1)`;  此时E：10000000010 = 1026
16:` (-1)^0 * 2^(1027-1023)*(0+1)`; 此时E：10000000011 = 1027
6 : 4.5转为二进制是110，科学计数法：1.1*2^2
* S = 0
* E = 2 + 1024 = 1026, 即：10000000010
* M = 110(第一个为隐藏位)

> 0.1+0.2 !==0.3的原因：
    在将0.1转为二进制的时候损失了一次精度
    在将0.2转为二进制的时候损失了一次精度
    在计算 0.1+0.2 的时候损失了一精度
    所以一共损失了三次精度，肯定与后面的0.3是不相等的。
> 正确做法：和精度做比较
`console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);  // true`


#### 2.5 String
(1) **语法表示**
* 双引号 "hello"
* 单引号 'hello'
* 反引号 \`hello\`

特殊字符要使用反斜杠 `\` 进行转义

(2) **相关概念**
`字符`:  用code point来表示。 code point就是一个数字，比如97表示a

`字节`: 计算机中存储的基本单位。  eg. a用97表示，占不到一个字节

`字符集`:
* ASCII码
* Unicode （全世界的各种字符）
* UCS  （Unicode和另一个标准化组织合并产生的）
* GB(国标) （国家或地区）
* ISO-8859 （东欧）
* BIG5 (台湾)

(3) **编码方式--Unicode的UTF编码**
UTF8： 默认8个比特位（一个字节）表示一个字符, eg. 
'a': 00100001
'b': 01100001
'一': 11100100 10111000 10000000 (111表示控制位，表示‘一’ 要占3个字节)

UTF16:默认16个比特位（两个字节）表示一个字符 eg.
'a': 00000000 00100001
'b': 00000000 01100001

#### 2.6 Symbol
Symbol类型专门用于object的属性名，可以保证对象的属性名不重名，表示独一无二的值。

**特点：** 
* 不能用new来创建
* 相同参数的Symbol值不相等 （参数只是描述，方面console查看）
* 不能与其他类型值进行运算，会报错
* 作为对象属性名，不能使用点操作符（使用使用方括号 或者Object.defineProperty()）


#### 2.7 Object
**(1) 对象的基本知识**

**特点** 
* 任何一个对象都是唯一的，与它本身的状态无关
* 即使两个状态完全一致的对象，也不相等
* 用状态来描述对象
* 状态的改变即是行为

**对象的要素**
* 唯一性标识： identifer
* 状态：state
* 行为：behavior

**对象描述方式**
* 分类（由顶向下）--  多继承(c++)
* 归类（自底向上） -- 单继承(c#,java)
* 原型(相似性)  --  任何对象只要描述它自己和原型的区别即可(javascript)

**(2) Javascript对象**

Javascript对象表示一组属性的集合（属性名:属性值）

属性名 可以是String类型的，也可以是Symbol类型的
属性值分为：数据属性和访问器属性

数据属性：
* \[[value]]: 属性的值
* writable: 决定属性能否被赋值
* enumerable: 决定 for in 能否枚举该属性
* configrable ：决定该属性能否被删除或者改变特征


访问器属性：
* get: 函数或 undefined，在取属性值时被调用
* set: 函数或 undefined，在设置属性值时被调用
* enumerable: 决定 for in 能否枚举该属性
* configrable ：决定该属性能否被删除或者改变特征


**(3) 原型链机制**
* 如果所有对象都有私有字段 \[[prototype]]，就是对象的原型；
* 读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。构成了原型链


**(4) 对象的API** 
基本对象机制的API：
* {}  创建对象
* .  点符号访问对象
* []  方括号访问对象
* Object.defineProperty()  定义对象的描述

基于原型的对象API: 
* Object.create()  指定原型下创建新对象
* Object.setPropertyOf(a,b)  修改原型
* Object.getPropertyOf(a)  获取原型

基于分类的方式描述对象
* new  
* class  定义类
* extends 继承

判断对象和属性关系的API
* hasOwnProperty(propertyName) 检查给定的属性在当前对象实例中是否存在
* isPropertyOf() 用于检查传入的对象是否是当前对象的原型
* propertyIsEnumerable（propertyname） 检查给定的属性是否能够使用for-in枚举
